// Refer: https://firebase.google.com/docs/auth/admin/verify-id-tokens#verify_id_tokens_using_a_third-party_jwt_library

// Generated by Gemini 2.5 Flash
import { importX509, type JWTVerifyResult, jwtVerify } from "jose";

import isDevelopment from "~/shared/utils/is-development";
import Log from "~/shared/utils/terminal-logger";

const FIREBASE_PROJECT_ID = process.env.FIREBASE_PROJECT_ID;

if (!FIREBASE_PROJECT_ID) {
  throw new Error(
    "FIREBASE_PROJECT_ID is not defined in environment variables. Please set it."
  );
}

// Firebase Session Cookie Public Keys URL as per your specification
const SESSION_COOKIE_JWKS_URL =
  "https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys";

// Cache for JWKS (JSON Web Key Set)
interface JwksCache {
  keys: Record<string, string>;
  expiresAt: number; // Unix timestamp in milliseconds
}

let jwksCache: JwksCache | null = null;

/**
 * Fetches and caches Firebase session cookie public keys based on Cache-Control header.
 * @returns A record of key IDs to public keys.
 * @throws Error if fetching fails.
 */
async function getSessionCookieJwks(): Promise<Record<string, string>> {
  // If cache exists and is not expired, return cached keys
  if (jwksCache && Date.now() < jwksCache.expiresAt) {
    return jwksCache.keys;
  }

  try {
    const response = await fetch(SESSION_COOKIE_JWKS_URL);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch session cookie JWKS: ${response.statusText} (Status: ${response.status})`
      );
    }

    const keys = await response.json();

    // Determine cache expiry from Cache-Control header
    const cacheControl = response.headers.get("Cache-Control");
    let maxAge = 3600; // Default to 1 hour if no max-age is found
    if (cacheControl) {
      const maxAgeMatch = cacheControl.match(/max-age=(\d+)/);
      if (maxAgeMatch?.[1]) {
        maxAge = parseInt(maxAgeMatch[1], 10);
      }
    }
    const expiresAt = Date.now() + maxAge * 1000; // Convert seconds to milliseconds

    jwksCache = { expiresAt, keys };
    return keys;
  } catch (error) {
    Log.fail(`Error in getSessionCookieJwks: ${error}`);
    jwksCache = null; // Invalidate cache on error
    throw error;
  }
}

/**
 * Verifies a Firebase session cookie using the 'jose' library and Firebase's specifications.
 * @param sessionCookie The Firebase session cookie string.
 * @returns The decoded JWT payload if verification is successful.
 * @throws Error if verification fails due to invalid token, expired token, or constraint violations.
 */
export async function verifyFirebaseSessionCookie(
  sessionCookie: string
): Promise<JWTVerifyResult["payload"]> {
  if (!sessionCookie) {
    throw new Error("Session cookie is empty or null.");
  }

  // --- DEVELOPMENT-ONLY BYPASS FOR FIREBASE AUTH EMULATOR ---
  // IMPORTANT: This block MUST NOT be present in production code!
  // It trusts tokens from the emulator without cryptographic verification.

  if (isDevelopment()) {
    try {
      // For emulator tokens, we can often just decode the payload directly.
      // They typically don't have a valid signature anyway.
      const [, payloadB64] = sessionCookie.split(".");
      if (payloadB64) {
        const decodedPayload = JSON.parse(
          Buffer.from(payloadB64, "base64url").toString("utf8")
        );
        // Basic check to ensure it looks like a Firebase token (has 'sub' claim)
        if (decodedPayload.sub) {
          Log.warn(
            "Firebase Auth Emulator detected. Bypassing full session cookie verification."
          );
          return decodedPayload;
        }
      }
    } catch (e) {
      Log.fail(
        `Failed to parse emulator token directly, attempting full verification: ${e}`
      );
      // Fall through to full verification if direct parsing fails
    }
  }
  // --- END OF DEVELOPMENT-ONLY BYPASS ---

  const jwks = await getSessionCookieJwks();

  // 1. Verify header: 'alg' is "RS256", 'kid' corresponds to public key
  const [headerB64] = sessionCookie.split(".");
  if (!headerB64) {
    throw new Error("Invalid JWT format: missing header part.");
  }
  const header = JSON.parse(
    Buffer.from(headerB64, "base64url").toString("utf8")
  );

  if (header.alg !== "RS256") {
    throw new Error(
      `Invalid algorithm: expected "RS256", got "${header.alg}".`
    );
  }
  const publicKey = jwks[header.kid];
  if (!publicKey) {
    throw new Error(`Public key not found for kid: "${header.kid}".`);
  }

  // Import the X.509 public key for verification
  const importedKey = await importX509(publicKey, "RS256");

  // 2. Verify payload and signature using jose
  // jose's jwtVerify handles exp, iat, aud, iss, and alg checks automatically
  const { payload } = await jwtVerify(sessionCookie, importedKey, {
    algorithms: ["RS256"], // Ensure the algorithm matches
    audience: FIREBASE_PROJECT_ID, // As per spec
    issuer: `https://session.firebase.google.com/${FIREBASE_PROJECT_ID}`, // As per spec
  });

  // 3. Additional payload checks as per specification (sub, auth_time)
  // 'sub' (subject) must be a non-empty string and the UID
  if (typeof payload.sub !== "string" || payload.sub.length === 0) {
    throw new Error("Invalid subject (sub) claim: must be a non-empty string.");
  }

  // 'auth_time' must be in the past. It's in seconds since epoch.
  if (
    typeof payload.auth_time !== "number" ||
    payload.auth_time * 1000 > Date.now()
  ) {
    throw new Error(
      "Invalid authentication time (auth_time) claim: must be in the past."
    );
  }

  return payload;
}
